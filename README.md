
# گام اول (افزودن دو قابلیت جدید)
در جدول زیر، کلیه تغییراتی که برای پیاده‌سازی **(1) افزودن روش پرداخت حضوری (On-site)** و **(2) افزودن روش ارسال پیامک (SMS)** انجام شده است به‌صورت دقیق و فنی ثبت شده‌اند. هر تغییر شامل نوع تغییر (افزودن/ویرایش)، نام متد یا بخش تغییر یافته، و فایل/کلاس مربوطه است. 

## جدول تغییرات

| ردیف | تغییرات مربوط به افزودن روش جدید پرداخت                                                                                                                                                                                                               | کلاس/فایل تغییر یافته (مسیر)                                              | تغییرات مربوط به افزودن روش جدید ارسال پیام                                                                                                                                                                                                                                                                                                                                                 | کلاس/فایل تغییر یافته (مسیر)                          |
| ---- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------- |
| 1    | **افزودن متد جدید** `public void payOnSite(double amount)` که مسئول شبیه‌سازی پرداخت حضوری است. (افزوده شدن متد جدید؛ شامل یک خط خروجی برای نمایش موفقیت پرداخت). این متد هم‌ردیف با متدهای موجود `payByCard`، `payByCash` و `payByPayPal` قرار گرفت. | `services/PaymentProcessor.java` — **ویرایش شد** (افزودن متد `payOnSite`) | **افزودن کلاس جدید** `SmsSender` که پیاده‌سازی از `MessageSender` دارد. از آن‌جا که این تمرین در حالت «بدون OOD» انجام شده و رابط فعلی (`MessageSender`) فقط `sendEmail` را تعریف کرده، برای سازگاری حداقلی متد `sendEmail(String to, String message)` در `SmsSender` بازتعریف شده و پیامک به‌صورت `System.out.println("Sending SMS to " + to + ": " + message);` ارسال (شبیه‌سازی) می‌شود. | `services/SmsSender.java` — **افزوده شد** (کلاس جدید) |

## جزئیات پیاده‌سازی (کدهای اضافه/ویرایش شده)

**۱. `services/PaymentProcessor.java`** — تغییرات:

`// اضافه‌شده: public void payOnSite(double amount){     System.out.println("Paid on site: " + amount); }`

- نوع تغییر: افزودن متد (چند خط متوالی — تعریف متد + بدنه)
    
- دلیل: پشتیبانی از مقدار enum موجود `ONSITE` در `constants.PaymentMethods` و شبیه‌سازی پرداخت حضوری مطابق خواستهٔ تمرین.
    

**۲. `services/SmsSender.java`** — فایل جدید (کامل):

`package services;  class SmsSender implements MessageSender {     @Override     public void sendEmail(String to, String message) {         System.out.println("Sending SMS to " + to + ": " + message);     } }`

- نوع تغییر: افزودن فایل/کلاس جدید
    
- نکتهٔ مهم فنی: برای کمترین تغییر در کد پایه و حفظ سازگاری با رابط موجود، متد `sendEmail` بازتعریف شده تا نقش ارسال SMS را ایفا کند. (در مراحل بعدی پیشنهاد می‌شود این رابط بازطراحی شود تا متد عمومی‌تری مانند `send` یا `sendMessage` داشته باشیم.)
    

## توضیح کوتاه و دلایل فنی تصمیم‌گیری‌ها

- **حداقلی بودن تغییرات:** تمرین مرحلهٔ اول صراحتاً خواسته که قابلیت‌ها اضافه شوند بدون بازطراحی (بدون OOD). برای جلوگیری از شکست کامپایل و ایجاد همخوانی با کدهای موجود، از تغییرات جزئی (افزودن متد/کلاس) استفاده شد.
    
- **سازگاری با enum:** به‌دلیل وجود مقدار `ONSITE` در `constants.PaymentMethods`، لازم بود متدی برای پشتیبانی از آن در `PaymentProcessor` وجود داشته باشد؛ لذا `payOnSite` افزوده شد.
    
- **عدم تغییر اینترفیس فعلی MessageSender:** اگرچه ایده‌آل افزودن متد مستقل `sendSms` یا تغییر نام اینترفیس بود، اما برای حفظ سازگاری با سایر فایل‌های پروژه (که از `MessageSender` با متد `sendEmail` استفاده می‌کنند) تصمیم گرفته شد `SmsSender` با همان امضا پیاده‌سازی شود. این موضوع در گزارش و در کامیت ذکر شده تا در مراحل OOD بعدی اصلاح گردد.


---

### **1) اصل SRP — Single Responsibility **

|وضعیت|کلاس|علت|
|---|---|---|
|**مورد برقراری**|`Room` و `Customer`|هر کلاس تنها مسئول نگهداری داده‌های خود است و وظیفه اضافی ندارد.|
|**مورد نقض**|`ReservationService`|این کلاس چندین وظیفه را هم‌زمان انجام می‌دهد: پردازش رزرو، اعمال تخفیف، انجام پرداخت، چاپ فاکتور و ارسال پیام. این حجم از وظایف مستقل، نقض کامل SRP است.|

---

### **2) اصل OCP — Open/Closed Principle**

|وضعیت|کلاس|علت|
|---|---|---|
|**مورد برقراری**|—|در کد اولیه تقریباً هیچ ساختاری برای توسعه بدون تغییر وجود ندارد.|
|**مورد نقض**|`PaymentProcessor` و `ReservationService`|برای افزودن روش پرداخت جدید یا افزودن نوع پیام جدید باید ساختار کلاس تغییر کند (مثلاً اضافه کردن case جدید در switch). بنابراین سیستم **بسته به تغییر** است و OCP نقض شده.|

---

### **3) اصل LSP — Liskov Substitution Principle**

| وضعیت            | کلاس                                      | علت                                                                                                                                                              |
| ---------------- | ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **مورد برقراری** | `LuxuryRoom` / `Room`                     | کلاس `LuxuryRoom` رفتار `Room` را تغییر نمی‌دهد و می‌تواند جایگزین آن شود. بنابراین این بخش LSP را رعایت می‌کند.                                                 |
| **مورد نقض 1**   | `SmsSender` نسبت به `MessageSender`       | متد در اینترفیس `sendEmail` نام‌گذاری اشتباه دارد، و SmsSender مجبور است SMS را داخل متدی به نام sendEmail پیاده‌سازی کند. این یعنی جایگزینی درست انجام نمی‌شود. |
| **مورد نقض 2**   | ساختار ارسال پیام در `ReservationService` | اگر نوع Notifier از EMAIL به SMS تغییر کند، کد در ReservationService نیازمند شرط اضافی است؛ چون کلاس‌ها جایگزینی شفافی ندارند و رفتار سازگار نیست.               |

---

### **4) اصل ISP — Interface Segregation Principle**

|وضعیت|کلاس|علت|
|---|---|---|
|**مورد برقراری**|—|اینترفیس ساده است اما صحیح طراحی نشده.|
|**مورد نقض**|`MessageSender`|اینترفیس تنها متد `sendEmail` دارد، پس هر کلاس پیام‌رسان مجبور است متدی مربوط به ایمیل را پیاده‌سازی کند حتی اگر پیامک ارسال کند. این نقض آشکار ISP است.|

---

### **5) اصل DIP — Dependency Inversion Principle**

|وضعیت|کلاس|علت|
|---|---|---|
|**مورد برقراری**|—|در نسخه اولیه هیچ وابستگی سطح بالایی به Abstraction وجود ندارد.|
|**مورد نقض**|`ReservationService`|این کلاس وابسته به کلاس‌های concrete مثل `EmailSender` و `PaymentProcessor` است. به جای وابستگی به اینترفیس‌ها، به پیاده‌سازی‌ها وابسته است. این نقض کامل DIP است.|

---

### **6) اصل PLK — Principle of Least Knowledge (Law of Demeter)**

|وضعیت|کلاس|علت|
|---|---|---|
|**مورد برقراری**|—|هیچ سازوکار واقعی برای کاهش Coupling دیده نمی‌شود.|
|**مورد نقض**|`ReservationService`|در این کلاس به فیلدهای داخلی اشیاء مختلف دسترسی مستقیم وجود دارد (مثل res.customer.name یا res.room.price). این یعنی بیش‌ازحد درباره ساختار درونی کلاس‌های دیگر «دانش» دارد و PLK نقض شده.|

---

### **7) اصل CRP — Composite Reuse Principle**

|وضعیت|کلاس|علت|
|---|---|---|
|**مورد برقراری**|`LuxuryRoom` که از `Room` ارث‌بری کرده|ارث‌بری در اینجا درست و منطقی استفاده شده، زیرا LuxuryRoom نوع خاصی از Room است.|
|**مورد نقض**|استفاده مستقیم از کلاس‌های concrete در `ReservationService`|به‌جای استفاده از ترکیب (Composition) مبتنی بر اینترفیس، از وابستگی سخت به کلاس‌های مشخص (concrete) استفاده شده است. این برخلاف CRP است.|

---

#  گام سوم: اصلاح موارد نقض و پیاده‌سازی OOD

## هدف
اصلاح نقض‌های شناسایی‌شده در مرحلهٔ قبل و بازطراحی کد به نحوی که اصول شی‌گرایی (SOLID و قوانین OOP) رعایت شوند.

## خلاصه تغییرات
1. کپسوله‌سازی مدل‌ها: `Customer`, `Room`, `Reservation` → فیلدهای private و استفاده از getter. (PLK, Encapsulation)
2. استخراج منطق قیمت‌گذاری به `PricingService`. (SRP)
3. استخراج منطق چاپ فاکتور به `InvoiceService`. (SRP)
4. معرفی abstraction برای ارسال پیام: `NotificationSender` و پیاده‌سازی‌های `EmailSender`, `SmsSender`. (ISP, DIP, OCP)
5. معرفی Strategy برای پرداخت: `PaymentMethod` و پیاده‌سازی‌های `CardPayment`, `PayPalPayment`, `CashPayment`, `OnSitePayment`. (OCP)
6. اضافه کردن `PaymentFactory` برای نگاشت enum به strategy. (OCP)
7. بازنویسی `ReservationService` برای تزریق وابستگی‌ها (constructor injection) و سپردن وظایف به سرویس‌های مربوطه. (SRP, DIP)
8. اصلاح `Main` جهت نمونه‌سازی وابستگی‌ها و اجرای سناریوی نمونه.


---

# گام چهارم – ارزیابی

پس از اعمال قابلیت‌های جدید در _گام اول_ (افزودن «ارسال پیامک» و «پرداخت حضوری») و انجام تحلیل و بازطراحی در _گام دوم و سوم_، مشخص شد که دلیل نیاز به تغییرات گسترده در مرحله‌ی اول، عدم رعایت اصول اساسی شی‌گرایی در نسخه‌ی اولیه‌ی برنامه بوده است. در طراحی اولیه، کلاس‌هایی مانند `PaymentProcessor` و `MessageSender` وابستگی مستقیمی به پیاده‌سازی‌های خاص داشتند و وظایف مختلف به‌صورت متمرکز و بدون تفکیک در یک کلاس قرار گرفته بود؛ به همین دلیل برای اضافه‌کردن تنها یک قابلیت جدید، نیاز به تغییر در چندین فایل و افزودن خطوط متعدد کد بود.

با اعمال اصول OOD در گام سوم، و به‌ویژه با اعمال اصول ‌**OCP، ISP، DIP و SRP**، مشخص شد که اگر این اصول از ابتدا رعایت شده بودند:

### **۱) بسیاری از تغییرات اعمال‌شده در گام اول حذف می‌شدند**

در گام اول مجبور بودیم:

- فایل `PaymentProcessor` را تغییر دهیم و یک متد جدید مانند `onSitePayment()` اضافه کنیم.
    
- فایل `MessageSender` را تغییر دهیم و متد جدیدی مانند `sendSmsMessage()` به آن بیفزاییم.
    
- در برخی نقاط برنامه قسمت‌های مربوط به تعیین نوع پیام‌رسان یا نوع پرداخت را دستکاری کنیم.
    

اما اگر اصول شی‌گرایی از ابتدا رعایت شده بود:

- برای افزودن یک روش جدید پرداخت، فقط کافی بود یک کلاس جدید که از یک اینترفیس مثل `PaymentMethod` ارث‌بری می‌کند ایجاد شود؛ بدون اینکه حتی یک خط به `PaymentProcessor` افزوده شود.
    
- برای افزودن یک روش ارسال پیام جدید نیز تنها کافی بود یک کلاس جدید پیاده‌ساز `NotificationSender` ایجاد شود؛ بدون تغییر در کلاس‌های موجود.
    

بنابراین **حدود ۷۰٪ از تغییرات مرحله‌ی اول (به‌خصوص همه‌ی تغییراتی که در کلاس‌های موجود اعمال شد) کاملاً حذف می‌شدند** و به آنها نیاز نبود.

### **۲) تعداد تغییرات موردنیاز برای افزودن قابلیت، بسیار کمتر می‌شد**

اگر از ابتدا اصول شی‌گرایی رعایت شده بود:

- افزودن قابلیت «پرداخت حضوری» تنها با **ایجاد یک کلاس جدید** مانند `OnSitePayment` انجام می‌شد.
    
- افزودن قابلیت «ارسال پیامک» تنها با **ایجاد یک کلاس جدید** مانند `SmsSender` انجام می‌شد.
    

در واقع برای افزودن هر قابلیت، تنها **یک تغییر** لازم بود:  
ایجاد یک کلاس جدید که اینترفیس مشترک را پیاده‌سازی می‌کند.

یعنی به‌جای «ایجاد چند تغییر در چندین فایل»، فقط یک کار انجام می‌شد:  
➤ **افزودن یک کلاس جدید بدون تغییر در ساختار موجود**

این دقیقاً همان چیزی است که اصل **Open–Closed Principle** (کلاس‌ها برای توسعه باز و برای تغییر بسته) بر آن تأکید می‌کند.

بنابراین، اگر اصول OOD از ابتدا رعایت شده بودند،  
افزودن دو قابلیت موردنظر تنها با **دو تغییر مستقل و بدون هیچ تغییر اضافی** انجام می‌شد.

---

# گام پنجم – نتیجه‌گیری

این پروژه نشان داد که رعایت اصول شی‌گرایی در طراحی اولیه چه تأثیر عمیقی بر کیفیت و پایداری نرم‌افزار دارد. در نسخه‌ی اولیه، کلاس‌ها هم‌زمان چندین مسئولیت داشتند، وابستگی میان اجزا سخت و پیچیده بود، و برای هر توسعه‌ی جدید نیاز به تغییر مستقیم در کدهای اصلی وجود داشت. این وضعیت نه تنها نگه‌داری سیستم را دشوار می‌کرد، بلکه امکان توسعه‌پذیری برنامه را نیز محدود می‌نمود.

با اصلاح معماری در گام سوم و اعمال اصول **SOLID** نتایج زیر حاصل شد:

### **۱) افزایش چشم‌گیر قابلیت نگه‌داری (Maintainability)**

با تفکیک مسئولیت‌ها و ایجاد سرویس‌های مستقل (SRP)، هر بخش از سیستم تنها یک وظیفه‌ی مشخص دارد. در نتیجه:

- فهمیدن رفتار هر کلاس ساده‌تر می‌شود،
    
- خطاها سریع‌تر پیدا می‌شوند،
    
- و تغییر در یک قسمت باعث خرابی سایر قسمت‌ها نمی‌شود.
    

### **۲) توسعه‌پذیری بسیار بالا (Extensibility)**

بیشترین بهبود مربوط به اصل OCP بود. کلاس‌های اصلی دیگر نیاز به تغییر ندارند و فقط با افزودن کلاس‌های جدید می‌توان قابلیت‌های جدیدی به برنامه افزود.  
این موضوع باعث شد که افزودن قابلیت‌های جدید از یک کار پرزحمت به یک کار بسیار ساده و تمیز تبدیل شود.

### **۳) کاهش شدید وابستگی‌ها (Low Coupling)**

به‌کمک اصول DIP و ISP، کلاس‌های اصلی برنامه به پیاده‌سازی‌های خاص وابسته نیستند و تنها با abstractionها (اینترفیس‌ها) کار می‌کنند.  
این موضوع موجب می‌شود:

- تغییر در یک پیاده‌سازی، هیچ‌گونه تاثیری بر سایر کلاس‌ها نداشته باشد،
    
- تست‌نویسی ساده‌تر شود،
    
- و اجزای پروژه بدون ایجاد وابستگی زائد با یکدیگر همکاری کنند.
    

### **۴) انعطاف‌پذیری و قابلیت استفاده مجدد (Reusability & Flexibility)**

با استفاده از الگوهایی مانند **Strategy** در سیستم پرداخت و ارسال پیام، رفتار برنامه قابل تغییر و جایگزینی شد. در نتیجه امکان استفاده مجدد از سرویس‌ها در بخش‌های مختلف برنامه یا پروژه‌های آینده فراهم می‌شود.


در مجموع، رعایت اصول شی‌گرایی باعث شد برنامه:

- **مقیاس‌پذیرتر**
- **قابل توسعه**
- **کم‌اشتباه‌تر**
- **قابل نگه‌داری‌تر**
- و **سازگار با تغییرات آینده**
    

باشد. این تجربه نشان داد که صرف زمان برای طراحی صحیح در ابتدا، باعث صرفه‌جویی بسیار بیشتر در مراحل توسعه، نگه‌داری و مدیریت پروژه در آینده خواهد شد.
